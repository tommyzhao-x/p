I"<h1 id="在golang中如何保障一个func只会执行一次">在golang中如何保障一个func只会执行一次</h1>

<h2 id="背景">背景</h2>

<p>在项目开发中，会遇到这样的场景：</p>

<ol>
  <li>使用单例模式初始化一些开销比较大的资源</li>
</ol>

<p>遇到这样的问题时，打击第一个想法就是使用sync.Once或者atomic.Value</p>

<h3 id="如何使用atomic保障原子执行">如何使用atomic保障原子执行</h3>

<p>大家都知道atomic使用CAS机制保障了操作的原子性，那么使用cas能够保障func只执行一次吗？如下面示例：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
	<span class="s">"sync/atomic"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
	<span class="n">done</span> <span class="kt">uint32</span>
	<span class="n">wg</span>   <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">oncedo</span><span class="p">()</span>
	<span class="k">go</span> <span class="n">oncedo</span><span class="p">()</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">oncedo</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">CompareAndSwapUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"func run"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>f()正常执行下这个逻辑是没有问题的。但是如果并发执行时，第一个抢到执行机会的goruntine在执行过程中f()，会导致后续的goroutine立即返回抢占失败；如果这里是初始化db链接，没有抢占到执行的函数返回后，业务还需要感知db是否可用。</p>

<p>那么能否保证所有的goroutine在返回时都能保证f()是被调用完成呢？可否使用sync.Once来保障？可以的话sync.Once又是如何处理的呢？</p>

<p>打开sync.Once的源码，我们可以看到它是用了两端提交的思想来保证的。</p>

<ol>
  <li>首先，检查done是否已经执行过</li>
  <li>如果没有执行过，加锁执行f()</li>
  <li>后续goroutine进来后，如果f()未执行完成，会被mutex同步阻塞</li>
  <li>执行成功后，把done置为1，然后再释放锁</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">Once</span><span class="p">)</span> <span class="n">Do</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">.</span><span class="n">done</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">o</span><span class="o">.</span><span class="n">doSlow</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">Once</span><span class="p">)</span> <span class="n">doSlow</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">done</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">atomic</span><span class="o">.</span><span class="n">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">.</span><span class="n">done</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">f</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

:ET