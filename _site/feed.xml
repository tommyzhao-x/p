<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-29T12:20:43+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">TommyZhao</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">在golang中如何保障一个func只会执行一次</title><link href="http://localhost:4000/golang/2021/01/29/golang-sync-once.html" rel="alternate" type="text/html" title="在golang中如何保障一个func只会执行一次" /><published>2021-01-29T00:00:00+08:00</published><updated>2021-01-29T00:00:00+08:00</updated><id>http://localhost:4000/golang/2021/01/29/golang-sync-once</id><content type="html" xml:base="http://localhost:4000/golang/2021/01/29/golang-sync-once.html"><![CDATA[<h1 id="在golang中如何保障一个func只会执行一次">在golang中如何保障一个func只会执行一次</h1>

<h2 id="背景">背景</h2>

<p>在项目开发中，会遇到这样的场景：</p>

<ol>
  <li>使用单例模式初始化一些开销比较大的资源</li>
  <li>分布式锁</li>
</ol>

<h2 id="如何正确解决这个冲突">如何正确解决这个冲突：</h2>

<p>先给出答案：</p>

<blockquote>
  <p>git merge –squash dev_base <br />
git pull origin master  <br />
git push origin dev_a</p>
</blockquote>

<h2 id="这里发生了什么">这里发生了什么？</h2>

<p>todo</p>]]></content><author><name></name></author><category term="golang" /><summary type="html"><![CDATA[在golang中如何保障一个func只会执行一次]]></summary></entry><entry><title type="html">如何解决git squash merge冲突</title><link href="http://localhost:4000/gitl/2019/03/01/git-squash-merge.html" rel="alternate" type="text/html" title="如何解决git squash merge冲突" /><published>2019-03-01T00:00:00+08:00</published><updated>2019-03-01T00:00:00+08:00</updated><id>http://localhost:4000/gitl/2019/03/01/git-squash-merge</id><content type="html" xml:base="http://localhost:4000/gitl/2019/03/01/git-squash-merge.html"><![CDATA[<h1 id="如何解决git-squash-merge冲突">如何解决git squash merge冲突</h1>

<h2 id="背景">背景</h2>

<p>公司项目使用了git大仓库管理代码，同一个仓库下会有多个业务代码。</p>

<p>平日里近百个开发在里面提交变更.</p>

<p>为了保证master的commit记录整洁，在提交mr时默认开启了gitlab的‘Squash commits when merge request is accepted’。</p>

<p>当有多部门系统开发时，有时会出现多部门同时基于一个非稳定分支开发（为了保持快速业务迭代）。</p>

<p>比如基础部门从master切出新分支，开发基础API，这里标记为：dev_base，在目录dev/app/base下coding。</p>

<p>当dev_base完成基础api开发，后部门A基于dev_base checkout一个分支：dev_a，在目录dev/app/a下coding，会引用dev/app/base的api。</p>

<p>后续dev_base和dev_a并行开发。</p>

<p>但是当dev_base开发完成，使用squash commits功能合并了master后。</p>

<p>这时dev_a合并master时，会在目录dev/app/base下存在大量冲突，然而他们从未变更过这个目录。</p>

<h2 id="如何正确解决这个冲突">如何正确解决这个冲突：</h2>

<p>先给出答案：</p>

<blockquote>
  <p>git merge –squash dev_base <br />
git pull origin master  <br />
git push origin dev_a</p>
</blockquote>

<h2 id="这里发生了什么">这里发生了什么？</h2>

<p>todo</p>]]></content><author><name></name></author><category term="gitl" /><summary type="html"><![CDATA[如何解决git squash merge冲突]]></summary></entry><entry><title type="html">Java项目问题排查规则</title><link href="http://localhost:4000/mvn/2018/07/10/java-product-troubshoting.html" rel="alternate" type="text/html" title="Java项目问题排查规则" /><published>2018-07-10T09:34:38+08:00</published><updated>2018-07-10T09:34:38+08:00</updated><id>http://localhost:4000/mvn/2018/07/10/java-product-troubshoting</id><content type="html" xml:base="http://localhost:4000/mvn/2018/07/10/java-product-troubshoting.html"><![CDATA[<h2 id="问题分类">问题分类</h2>

<ol>
  <li>CPU占用率高</li>
  <li>内存泄露</li>
</ol>

<h2 id="cpu占用率高">CPU占用率高</h2>

<ol>
  <li>在容器内执行top命令，找到cpu使用率高的pid</li>
  <li>执行top -pid xxx，查看当前pid2的具体信息</li>
  <li>按照cpu占用率排序，找到占有率最高的pid</li>
  <li>使用jstack pid打印当前java线程的执行情况</li>
  <li>命令行printf %0x pid2查看对应的16进制nid</li>
  <li>这jstack的thread dump中观察对应的栈信息</li>
</ol>

<h2 id="内存使用率高">内存使用率高</h2>

<ol>
  <li>jps -lvm找到当前容器运行的java线程</li>
  <li>找到对应问题的线程后执行，jmap -heap:format=b file=mem.bin pid</li>
  <li>使用mat或者jprofiler导入dump后，分析</li>
  <li>观察占用率较高的对象分布，基本可以确定问题</li>
</ol>]]></content><author><name></name></author><category term="mvn" /><summary type="html"><![CDATA[问题分类]]></summary></entry><entry><title type="html">Deploy jar to mvn nexus repository</title><link href="http://localhost:4000/mvn/2018/01/02/mvn-deplpy-to-nexus.html" rel="alternate" type="text/html" title="Deploy jar to mvn nexus repository" /><published>2018-01-02T17:34:38+08:00</published><updated>2018-01-02T17:34:38+08:00</updated><id>http://localhost:4000/mvn/2018/01/02/mvn-deplpy-to-nexus</id><content type="html" xml:base="http://localhost:4000/mvn/2018/01/02/mvn-deplpy-to-nexus.html"><![CDATA[<h1 id="deploy-jar-to-mvn-nexus-repository">Deploy jar to mvn nexus repository</h1>

<h2 id="add-server-config-to-settingsxml">Add server config to settings.xml</h2>
<p>进入.m2文件夹，更改settings.xml，添加server配置</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;server&gt;
       &lt;id&gt;my-nexus-release-server&lt;/id&gt;
       &lt;username&gt;xxxx&lt;/username&gt;
       &lt;password&gt;xxxx&lt;/password&gt;
     &lt;/server&gt;
</code></pre></div></div>
<h2 id="更改pomxml">更改pom.xml</h2>
<p>新增deploy仓库配置：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;distributionManagement&gt;
		&lt;repository&gt;
			&lt;id&gt;my-nexus-release-server&lt;/id&gt;
			&lt;name&gt;Internal Releases&lt;/name&gt;
			&lt;url&gt;http://nexus.my.co/content/repositories/releases&lt;/url&gt;
		&lt;/repository&gt;
		&lt;snapshotRepository&gt;
			&lt;id&gt;my-nexus-snapshots-server&lt;/id&gt;
			&lt;name&gt;Internal Snapshots&lt;/name&gt;
			&lt;url&gt;http://nexus.my.co/content/repositories/snapshots&lt;/url&gt;
		&lt;/snapshotRepository&gt;
	&lt;/distributionManagement&gt;
</code></pre></div></div>
<p>如果要上传source包，新增：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.0.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;attach&gt;true&lt;/attach&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;compile&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;jar&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre></div></div>]]></content><author><name></name></author><category term="mvn" /><summary type="html"><![CDATA[Deploy jar to mvn nexus repository]]></summary></entry><entry><title type="html">Golang compile tool</title><link href="http://localhost:4000/go/2017/11/21/go-tool-compile.html" rel="alternate" type="text/html" title="Golang compile tool" /><published>2017-11-21T20:34:38+08:00</published><updated>2017-11-21T20:34:38+08:00</updated><id>http://localhost:4000/go/2017/11/21/go-tool-compile</id><content type="html" xml:base="http://localhost:4000/go/2017/11/21/go-tool-compile.html"><![CDATA[<h1 id="golang-compile-tool">Golang compile tool</h1>

<h2 id="command">Command</h2>
<p>go tool compile -m -importmap go-common/log=tlog/vendor/go-common/log -D /Users/tommy/work/src/tlog  -I /Users/tommy/work/pkg/darwin_amd64  -S  main.go &gt; test/test1.s</p>]]></content><author><name></name></author><category term="go" /><summary type="html"><![CDATA[Golang compile tool]]></summary></entry><entry><title type="html">Golang获取本机IP地址</title><link href="http://localhost:4000/go/2017/08/29/go-internal-ip-address.html" rel="alternate" type="text/html" title="Golang获取本机IP地址" /><published>2017-08-29T20:34:38+08:00</published><updated>2017-08-29T20:34:38+08:00</updated><id>http://localhost:4000/go/2017/08/29/go-internal-ip-address</id><content type="html" xml:base="http://localhost:4000/go/2017/08/29/go-internal-ip-address.html"><![CDATA[<h1 id="golang获取本机ip地址">Golang获取本机IP地址</h1>

<h2 id="引子">引子</h2>
<p>最近有次灰度发版后，发现RPC client获取到一个莫名的RPC server ip，通过服务注册的管理界面也能看到这个IP，排查后发现是当前灰度的机器，但是此机器的IP并不是注册的ip。</p>

<p>排查代码后发现，先有注册的逻辑是这样的:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// InternalIP get internal ip.
func InternalIP() string {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return ""
	}
	for _, a := range addrs {
		if ipnet, ok := a.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String()
			}
		}
	}
	return ""
}
</code></pre></div></div>
<p>获取排除loopback地址后的ip。</p>

<p>But, 诡异的地方就是这个IsLoopback:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// IsLoopback reports whether ip is a loopback address.
func (ip IP) IsLoopback() bool {
	if ip4 := ip.To4(); ip4 != nil {
		return ip4[0] == 127
	}
	return ip.Equal(IPv6loopback)
}

</code></pre></div></div>
<p>它是通过判断非127开头的IP来判断的。</p>

<p>但是，我们服务灰度的这台物理机上绑定了个loopbakc，ip为：172开头。
so，逻辑失效。
发现问题后，更改了下获取本机IP的逻辑，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// InternalIP get internal ip.
func InternalIP() string {
	inters, err := net.Interfaces()
	if err != nil {
		return ""
	}
	for _, inter := range inters {
		if !strings.HasPrefix(inter.Name, "lo") {
			addrs, err := inter.Addrs()
			if err != nil {
				continue
			}
			for _, addr := range addrs {
				if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() {
					if ipnet.IP.To4() != nil {
						return ipnet.IP.String()
					}
				}
			}
		}
	}
	return ""
}

</code></pre></div></div>]]></content><author><name></name></author><category term="go" /><summary type="html"><![CDATA[Golang获取本机IP地址]]></summary></entry><entry><title type="html">Kafka中有两种consumer接口</title><link href="http://localhost:4000/kafka/2017/04/27/kafka-consumer.html" rel="alternate" type="text/html" title="Kafka中有两种consumer接口" /><published>2017-04-27T20:34:38+08:00</published><updated>2017-04-27T20:34:38+08:00</updated><id>http://localhost:4000/kafka/2017/04/27/kafka-consumer</id><content type="html" xml:base="http://localhost:4000/kafka/2017/04/27/kafka-consumer.html"><![CDATA[<h1 id="kafka-consumer">Kafka consumer</h1>

<p>Kafka中有两种consumer接口，分别为Low-level API和High-levelAPI</p>

<h2 id="low-level-api--simpleconsumer">Low-level API  SimpleConsumer</h2>
<blockquote>
  <p>这套接口比较复杂的，使用者必须要考虑很多事情，优点就是对Kafka可以有完全的控制。</p>
</blockquote>

<h2 id="high-level-api-zookeeperconsumerconnector">High-level API ZookeeperConsumerConnector</h2>
<blockquote>
  <p>High-level API使用比较简单，已经封装了对partition和offset的管理，默认是会定期自动commit offset，这样可能会丢数据的，因为consumer可能拿到数据没有处理完crash。 High-level API接口的特点，自动管理，使用简单，但是对Kafka的控制不够灵活。</p>
</blockquote>]]></content><author><name></name></author><category term="kafka" /><summary type="html"><![CDATA[Kafka consumer]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2017/04/27/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-04-27T10:34:38+08:00</published><updated>2017-04-27T10:34:38+08:00</updated><id>http://localhost:4000/jekyll/update/2017/04/27/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2017/04/27/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code class="language-plaintext highlighter-rouge">_posts</code> directory that follows the convention <code class="language-plaintext highlighter-rouge">YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry></feed>